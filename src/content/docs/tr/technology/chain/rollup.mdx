---
section: technology
date: Last Modified
title: "Rollup Süreci"
lang: "tr"
permalink: "technology/chain/rollup"
whatsnext: { "Ethereum EVM'inden Farklar": "/tr/technology/chain/differences/" }
---

import ClickToZoom from "../../../../../components/ClickToZoom.astro"
import RollupProcess from "../_images/rollup.png"

Bu belgede Scroll'daki rollup işlemi açıklanmaktadır.

## İş Akışı

<ClickToZoom src={RollupProcess} alt="Rollup Process" />

Şekilde rollup iş akışı gösterilmektedir. L2 sıralayıcısı üç modül içerir:

- **Senkronizasyon hizmeti** L1 köprü sözleşmesinden düzenlenen etkinliğe abone olur. L1 gelen kutusuna yeni eklenen mesajları tespit ettiğinde, Senkronizasyon Hizmeti buna göre yeni bir "L1MessageTx" işlemi oluşturacak ve bunu yerel L1 işlem kuyruğuna ekleyecektir.
- **Mempool** doğrudan L2 sıralayıcısına gönderilen işlemleri toplar.
- **Yürütücü** hem L1 işlem kuyruğundan hem de L2 bellek havuzundan işlemleri çeker ve yeni bir L2 bloğu oluşturmak için bunları yürütür.

Rollup düğümü üç modül içerir:

- **Aktarıcı**, veri kullanılabilirliği ve kesinliği için taahhüt işlemlerini ve sonlandırma işlemlerini rollup sözleşmesine gönderir.
- **Parça Teklif Edici** ve **Toplu Teklif Oluşturucu**, [İşlem Toplu İşleme](/tr/technology/chain/transactions#transaction-batching) bölümünde açıklanan kısıtlamalara uygun olarak yeni parçalar ve yeni gruplar önerir.

Rollup süreci üç aşamaya ayrılabilir: işlemin yürütülmesi, toplu işlem ve veri taahhüdü, kanıt oluşturma ve sonuçlandırma.

### Aşama 1. İşlemin Yürütülmesi

1. Kullanıcılar işlemleri L1 köprü sözleşmesine veya L2 sıralayıcılara gönderir.
2. L2 sıralayıcıdaki Senkronizasyon Hizmeti, köprü sözleşmesinden en son eklenen L1 işlemlerini getirir.
3. L2 sıralayıcı, L2 blokları oluşturmak için hem L1 mesaj kuyruğundan hem de L2 bellek havuzundan gelen işlemleri işler.

### Aşama 2. Gruplama ve Veri Taahhüdü

4. Toplama düğümü en son L2 bloklarını izler ve işlem verilerini getirir.
5. Kriter ([İşlem Toplu İşleme](/tr/technology/chain/transactions#transaction-batching) bölümünde açıklanan) karşılanırsa, rollup düğümü yeni bir yığın veya toplu iş önerir ve bunu veritabanına yazar. Aksi halde rollup düğümü daha fazla blok veya parça beklemeye devam eder.
6. Yeni bir toplu iş oluşturulduktan sonra, rollup aktarıcısı bu toplu işteki işlem verilerini toplar ve verilerin kullanılabilirliği için rollup sözleşmesine bir Taahhüt İşlemi gönderir.

### Aşama 3. Kanıt Oluşturma ve Sonlandırma

7. Koordinatör veri tabanından yeni bir parça veya partiyi yokladığında:
    - Yeni bir yığın üzerine koordinatör, L2 sıralayıcıdan bu yığındaki tüm blokların yürütme izlerini sorgulayacak ve ardından rastgele seçilen bir zkEVM kanıtlayıcıya bir yığın kanıtlama görevi gönderecektir.
    - Yeni bir parti üzerine, koordinatör bu partideki tüm parçaların parça kanıtlarını veri tabanından toplayacak ve rastgele seçilen bir toplayıcı kanıtlayıcıya bir toplu kanıtlama görevi gönderecektir.
8. Koordinatör kanıtlayıcıdan yığın veya toplu kanıt aldığında, kanıtı veri tabanına yazacaktır.
9. Rollup aktarıcısı veri tabanından yeni bir toplu kanıt topladığında, kanıtı doğrulamak için rollup sözleşmesine bir Sonlandırma İşlemi gönderecektir.

## Taahhüt İşlemi

Taahhüt İşlemi, veri kullanılabilirliği için blok bilgilerini ve işlem verilerini L1'e gönderir. İşlem, ana grup başlığını, öbek verilerini ve atlanan L1 mesajının bir bit eşlemini içerir. Ana toplu iş başlığı, bu toplu işin bağlandığı önceki toplu işi belirtir. Ana grup daha önce işlenmelidir; aksi takdirde işlem geri alınacaktır. Aşağıdaki `commitBatch` işlev imzasına bakın.

```solidity
function commitBatch(
    uint8 version,
    bytes calldata parentBatchHeader,
    bytes[] memory chunks,
    bytes calldata skippedL1MessageBitmap
) external override OnlySequencer
```

'commitBatch' işlevi ana grubun daha önce taahhüt edildiğini doğruladıktan sonra, grubun toplu iş başlığını oluşturur ve toplu iş başlığının karmasını 'ScrollChain' sözleşmesine kaydeder.

```solidity
mapping(uint256 => bytes32) public committedBatches;
```

Toplu başlık ve yığın verilerinin kodlanması [Codec](#codec) bölümünde açıklanmaktadır. Toplu iş başlığındaki alanların çoğu, yığın verilerinden türetilecek şekilde basittir. Dikkat edilmesi gereken önemli alanlardan biri, geçerlilik kanıtını doğrulamak için kamuya açık girdinin bir parçası haline gelecek olan 'dataHash'tır. Bir grubun "n" parça içerdiğini varsayarsak, "dataHash" aşağıdaki şekilde hesaplanır

```
batch.dataHash := keccak(chunk[0].dataHash || ... || chunk[n-1].dataHash)
```

Bir yığının 'k' blok içerdiğini varsayarsak, onun 'dataHash'ı aşağıdaki şekilde hesaplanır

```
chunk.dataHash := keccak(blockContext[0] || ... || blockContext[k-1] ||
                         block[0].l1TxHashes || block[0].l2TxHashes || ... ||
                         block[k-1].l1TxHashes || block[k-1].l2TxHashes)
```

burada "block.l1TxHashes" bu bloktaki L1 işlemlerinin birleştirilmiş işlem hash'leridir ve "block.l2TxHashes" bu bloktaki L2 işlemlerinin birleştirilmiş işlem hash'leridir. L1 işlemlerinin işlem hash'lerinin toplama düğümü tarafından yüklenmediğini, bunun yerine bu blokta yer alan L1 mesajlarının indeks aralığı göz önüne alındığında doğrudan "L1MessageQueue" sözleşmesinden yüklendiğini unutmayın. L2 işlem hash'leri, [`Chunk`](#Chunk-Codec) içindeki 'l2Transactions' alanındaki RLP kodlu baytlardan hesaplanır.

Ek olarak, 'commitBatch' işlevi atlanan L1 mesajlarının bir bit eşlemini içerir. Ne yazık ki bunun nedeni kanıt taşması sorunudur. Bir L1 mesajına karşılık gelen L1 işlemi devre kapasitesi sınırını aşarsa, bu işlem için geçerli bir kanıt oluşturamayacağız ve dolayısıyla L1'de sonlandıramayız. Scroll, kanıtlama sistemimizde yapılan yükseltmeler yoluyla kanıt taşması sorununu ortadan kaldırmak için aktif olarak çalışıyor.

## Sonlandırma İşlemi

Sonlandırma İşlemi, daha önce taahhüt edilen partiyi geçerlilik kanıtıyla sonlandırır. İşlem ayrıca toplu işlemden sonra durum kökünü ve çekilme kökünü de gönderir. İşte `finalizeBatchWithProof`un işlev imzası:

```solidity
function finalizeBatchWithProof(
    bytes calldata batchHeader,
    bytes32 prevStateRoot,
    bytes32 postStateRoot,
    bytes32 withdrawRoot,
    bytes calldata aggrProof
) external override OnlyProver
```

'finalizeBatchWithProof' işlevi ilk olarak toplu işin sözleşmede taahhüt edilip edilmediğini doğrular. Daha sonra genel giriş karmasını aşağıdaki gibi hesaplar

```
publicInputHash := keccak(chainId || prevStateRoot || postStateRoot || withdrawRoot || batch.dataHash)
```

Genel giriş hash'i ve geçerlilik kanıtı, plonk sağlamlık doğrulayıcıya gönderilir. Doğrulama başarılı olduktan sonra yeni durum kökü ve çekim kökü 'ScrollChain' sözleşmesinde saklanır.

```solidity
mapping(uint256 => bytes32) public override finalizedStateRoots;
mapping(uint256 => bytes32) public override withdrawRoots;
```

Bu aşamada en son sonuçlanan partinin durum kökü güvenilir bir şekilde kullanılabilir ve o partideki para çekme işlemleri, para çekme köküne Merkle kanıtı kullanılarak L1 üzerinden gerçekleştirilebilir.

## Codec

Bu bölümde Toplama sözleşmesindeki üç veri yapısının codec'i açıklanmaktadır: 'BatchHeader', 'Chunk' ve 'BlockContext'.

### `BatchHeader` Codec

| Field                    | Bytes   | Type        | Offset | Description                                                     |
| ------------------------ | ------- | ----------- | ------ | --------------------------------------------------------------- |
| `version`                | 1       | `uint8`     | 0      | The batch header version                                        |
| `batchIndex`             | 8       | `uint64`    | 1      | The index of the batch                                          |
| `l1MessagePopped`        | 8       | `uint64`    | 9      | The number of L1 messages poped in the batch                    |
| `totalL1MessagePopped`   | 8       | `uint64`    | 17     | The number of total L1 messages popped after the batch          |
| `dataHash`               | 32      | `bytes32`   | 25     | The data hash of the batch                                      |
| `parentBatchHash`        | 32      | `bytes32`   | 57     | The parent batch hash                                           |
| `skippedL1MessageBitmap` | dynamic | `uint256[]` | 89     | A bitmap to indicate which L1 messages are skipped in the batch |

### `Chunk` Codec

| Field            | Bytes   | Type           | Offset    | Description                                                                                                                                       |
| ---------------- | ------- | -------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| `numBlocks`      | 1       | `uint8`        | 0         | The number of blocks in the chunk                                                                                                                 |
| `block[0]`       | 60      | `BlockContext` | 1         | The block information of the 1st block                                                                                                            |
| ...              | ...     | ...            | ...       | ...                                                                                                                                               |
| `block[i]`       | 60      | `BlockContext` | `60*i+1`  | The block information of `i+1`-th block                                                                                                           |
| ...              | ...     | ...            | ...       | ...                                                                                                                                               |
| `block[n-1]`     | 60      | `BlockContext` | `60*n-59` | The block information of the last block                                                                                                           |
| `l2Transactions` | dynamic | `bytes`        | `60*n+1`  | The concatenated RLP encoding of L2 transactions with signatures. The byte length (`uint32`) of RLP encoding is inserted before each transaction. |

### `BlockContext` Codec

| Field             | Bytes | Type      | Offset | Description                                                                         |
| ----------------- | ----- | --------- | ------ | ----------------------------------------------------------------------------------- |
| `blockNumber`     | 8     | `uint64`  | 0      | The block number                                                                    |
| `timestamp`       | 8     | `uint64`  | 8      | The block time                                                                      |
| `baseFee`         | 32    | `uint256` | 16     | The base fee of this block. Currently, it is always 0, because we disable EIP-1559. |
| `gasLimit`        | 8     | `uint64`  | 48     | The gas limit of this block                                                         |
| `numTransactions` | 2     | `uint16`  | 56     | The number of transactions in this block, including both L1 & L2 txs                |
| `numL1Messages`   | 2     | `uint16`  | 58     | The number of L1 messages in this block                                             |
