---
section: technology
date: Last Modified
title: "zkTrie"
lang: "tr"
permalink: "technology/sequencer/zktrie"
whatsnext: { "zkEVM": "/tr/technology/zkevm/intro-to-zkevm/" }
excerpt: "zkTrie, Poseidon hashi kullanılarak oluşturulmuş seyrek bir ikili (binary) Merkle Patricia Trie'dir."
---

import Aside from "../../../../../components/Aside.astro"
import ClickToZoom from "../../../../../components/ClickToZoom.astro"
import zktrie1 from "../_images/zktrie-arch.png"
import zktrie2 from "../_images/zktrie-insertion.png"
import zktrie3 from "../_images/zktrie-deletion.png"

Bu belgede, anahtar/değer çiftlerini verimli bir şekilde depolamak için kullanılan seyrek bir ikili Merkle Patricia Trie olan zkTrie açıklanmaktadır. Ekleme ve silme de dahil olmak üzere ağaç yapısını, yapısını, düğüm hash işlemini ve ağaç işlemlerini açıklar.

Ayrıca [zktrie repomuzu](https://github.com/scroll-tech/zktrie) de inceleyebilirsiniz.

## Ağaç Yapısı

zkTrie, aşağıdaki şekilde gösterildiği şekilde seyrek bir ikili Merkle Patricia Trie'dir.
Seyrek İkili Merkle Patricia Trie konusuna dalmadan önce Merkle Trees ve Patricia Tries'e kısaca değinelim.
* **Merkle Ağacı**: Merkle Ağacı, her yaprak düğümünün bir veri bloğunun hash değerini temsil ettiği ve yaprak olmayan her düğümün, alt düğümlerinin hash değerini temsil ettiği bir ağaçtır.
* **Patricia Trie**: Patricia Trie, anahtar/değer çiftlerini verimli bir şekilde depolamak için kullanılan bir tür taban ağacı veya sıkıştırılmış trie'dir. Yolun düğüm anahtarının değeri tarafından belirlendiği ortak yolu paylaşmak için düğümleri aynı anahtar önekiyle kodlar.

Şekil 1'de gösterildiği gibi zkTrie'de üç tip düğüm vardır.
- Dal Düğümü: zkTrie'nin ikili bir ağaç olduğu göz önüne alındığında, bir dal düğümünün iki çocuğu vardır.
- Yaprak Düğümü: Bir yaprak düğümü, bir anahtar/değer çiftinin verilerini tutar.
- Boş Düğüm: Boş bir düğüm, aynı öneki paylaşan alt grubun boş olduğunu belirten özel bir düğüm türüdür.

zkTrie'de, düğüm hash değerini hesaplamak için Poseidon hash değerini kullanırız çünkü bunu zk devresinde kanıtlamak daha kolay ve verimlidir.

<ClickToZoom src={zktrie1} alt="zkTrie Structure" caption="Figure 1. zkTrie Structure" />

## Ağaç Yapımı

Bir anahtar/değer çifti verildiğinde, ilk önce Poseidon hash işlevini kullanarak orijinal anahtarı (yani hesap adresi ve depolama anahtarının) hashleyerek ilgili yaprak düğüm için bir *güvenli anahtar* hesaplarız. Bu, anahtarın anahtar alanı üzerinde tekdüze (uniform) dağıtılmasını sağlar. Düğüm anahtarı hash yöntemi, aşağıdaki [Node Hashing](#node-hashing) bölümünde açıklanmaktadır.

Yeni bir yaprak düğümün yolunu, güvenli anahtarı En Az Önemli Bit'ten (LSB) En Önemli Bit'e (MSB) geçerek kodluyoruz. Her adımda, eğer bit 0 ise soldaki çocuğa; aksi halde sağ çocuğa geçiyoruz.

ZkTrie'nin maksimum derinliğini 248 ile sınırlandırıyoruz; bu, ağacın anahtarın yalnızca alt 248 bitini geçeceği anlamına gelir. Güvenli anahtar alanı, Poseidon hashi tarafından kullanılan ve $2^{256}$ aralığının tamamını kaplamayan sonlu bir alan olduğundan, anahtarın bit temsili sonlu alanda belirsiz olabilir ve bu nedenle, zk devresinde bir sağlamlık sorunuyla sonuçlanır.

Yalnızca bir yaprak düğümü olan bir alt ağacı tek bir yaprak düğümüne daraltarak ağaç derinliğini azaltacak bir optimizasyon uyguluyoruz. Örneğin, Şekil 1'de ağacın toplamda '0100', '0010' ve '1010' tuşlarına sahip üç düğümü vardır. '00' son ekine sahip yalnızca bir düğüm olduğundan, '0100' anahtarının yaprak düğümü yalnızca '00' son ekini geçer ve 4 derinliğine neden olacak anahtarını tam olarak genişletmez.

## Ağaç İşlemleri

### Ekleme

<ClickToZoom src={zktrie2} alt="zkTrie Structure" caption="Figure 2. Insert a new leaf node to zkTrie" />

Bir zkTrie'ye yeni bir yaprak düğüm eklediğimizde, Şekil 2'de gösterilen iki durum vardır.

1. Düğüm anahtarının yolunu geçerken boş bir düğüme ulaşır (Şekil 2a). Bu durumda, bu boş düğümü bu yaprak düğümle değiştirmemiz ve dal düğümlerinin merkle hashini köke kadar güncellemek için yolu geriye doğru izlememiz gerekiyor.
2. Düğüm anahtarının yolunu kat ederken başka bir yaprak düğüm olan 'b'ye ulaşır (Şekil 2b). Bu durumda, iki yaprak düğümün düğüm anahtarlarındaki bir sonraki bit farklılaşana kadar mevcut yaprak düğümü 'b'yi aşağı itmemiz gerekir. Her aşağı itme adımında, dal düğümüne boş bir kardeş düğüm eklememiz gerekir. Bitlerin farklı olduğu seviyeye ulaştığımızda, bitlerine bağlı olarak sol çocuk ve sağ çocuk olarak iki yaprak düğümü 'b' ve 'd' yerleştiririz. Sonunda yolu geriye doğru izleriz ve tüm dal düğümlerinin Merkle hashini güncelleriz.

### Silme

<ClickToZoom src={zktrie3} alt="zkTrie Structure" caption="Figure 3. Delete a leaf node from the zkTrie" />

Bir yaprak düğümün silinmesi ekleme işlemine benzer. Şekil 3'te gösterilen iki durum vardır.

1. Silinecek yaprak düğümün kardeş düğümü,
dal düğümü (Şekil 3a). Bu durumda, 'a' düğümünü boş bir düğümle değiştirebilir ve atalarının düğüm karma değerini kök düğüme kadar güncelleyebiliriz.
2. Silinecek yaprak düğümün kardeş düğümü bir yaprak düğümdür (Şekil 3b). Durum 1'e benzer şekilde, önce yaprak düğümü boş bir düğümle değiştiririz ve kardeş düğümü boş bir düğüm olmayana kadar kardeş düğümünü yukarı doğru daraltmaya başlarız. Örneğin, Şekil 3b'de 'b' yaprak düğümünü boş bir düğümle değiştiriyoruz. 'c' düğümünün kardeşi artık boş bir düğüm haline geldiğinden, 'c' düğümünü bir seviye yukarı taşımamız ve ebeveynini değiştirmemiz gerekiyor. 'C' düğümünün yeni kardeşi 'e' düğümü hâlâ boş bir düğümdür. Böylece yine 'c' düğümünü yukarı doğru hareket ettiriyoruz. Artık 'c' düğümünün kardeşi bir yaprak düğüm olan 'a' düğümü olduğuna göre, silme işlemi tamamlanmıştır.

Geçerli bir zkTrie'deki yaprak düğümün kardeşinin boş bir düğüm olamayacağını unutmayın. Aksi halde her zaman alt ağacı budamalı ve yaprak düğümünü yukarı doğru hareket ettirmeliyiz.

## Düğüm Hash İşlemi

In this section, we will describe how leaf secure key and node Merkle hash are computed. We use Poseidon hash with arity 2 for both hashing computation. In Scroll, the Poseidon hash function is configured to take two field element inputs each time and a `domain_value` as the initial context for domain separation, denoted as follows.
```
h{domain_value}(input1, input2)
```

### Empty Node

The node hash of an empty node is 0.

### Branch Node

The branch node hash is computed as follows

```go
branchNodeHash = h{BranchNodeType}(leftChildHash, rightChildHash)
```

### Leaf Node

The node hash of a leaf node is computed as follows.

```go
leafNodeHash = h{LeafNodeType}(nodeKey, valueHash)
```

The computation involves two fields `nodeKey` and `valueHash`.
- `nodeKey` is hashed from the original key. The domain value used in the Poseidon hash is 256.
- `valueHash` is calculated by hashing the leaf node value. The domain value used in the Poseidon hash is `256 * n`, where `n` is the number of elements in the leaf node value.

There are two types of leaf nodes: Ethereum accounts and storage key-value pairs. Next, we will describe the calculation method of the node key and value hash for each leaf node type respectively.

#### Ethereum Account Leaf Node
For an Ethereum Account Leaf Node, it consists of an Ethereum address and a state account data structure. The secure key is derived from the Ethereum address.
```go
var address byte[20] // 20 bytes in big-endian
valHi := address[0:16]
valLo := address[16:20] * 2^96 // padding 12 bytes of 0 at the end
nodeKey := h{256}(valHi, valLo)
```

A state account struct in the Scroll consists of the following fields (`Fr` indicates the finite field and is a 254-bit value)

- `Nonce`: u64
- `Balance`: u256, but treated as Fr
- `StorageRoot`: Fr
- `KeccakCodeHash`: u256
- `PoseidonCodeHash`: Fr
- `CodeSize`: u64

Before computing the value hash, the state account is first marshaled into a list of `u256` values. The marshaling scheme is

```text
(The following scheme assumes the big-endian encoding)
[0:32]
	[0:16] Reserved with all 0
	[16:24] CodeSize, uint64 in big-endian
	[24:32] Nonce, uint64 in big-endian
[32:64] Balance
[64:96] StorageRoot
[96:128] KeccakCodeHash
[128:160] PoseidonCodehash
(total 160 bytes)
```

The marshal function also returns a `flag` value along with a vector of `u256` values. The `flag` is a bitmap that indicates whether a `u256` value cannot be treated as a field element (Fr). The `flag` value for state account is 8, shown below.

```
         +--------------------+---------+------+----------+----------+
 index   |          0         |    1    |   2  |     3    |     4    |
         +--------------------+---------+------+----------+----------+
  u256   | nonce||codesize||0 | balance | root |  keccak  | poseidon |
         +--------------------+---------+------+----------+----------+
flag bit |          0         |    0    |   0  |     1    |     0    |
         +--------------------+---------+------+----------+----------+
         (LSB)                                                   (MSB)
```

The value hash is computed in two steps:
1. Convert the value that cannot be represented as a field element of the Poseidon hash to the field element.
2. Combine field elements in a binary tree structure till the tree root is treated as the value hash.

In the first step, when the bit in the `flag` is 1 indicating the `u256` value that cannot be treated as a field element, we split the value into a high-128bit value and a low-128bit value, and then pass them to a Poseidon hash to derive a field element value, `h(valueHi, valueLo)`.

```go
// convert Keccak codehash to a field element
compressedKeccakCodeHash := h{512}(keccakCodeHash[0:16], keccakCodeHash[16:32])
```

Second, the value hash is computed as follows.

```go
domain := 256 * 5  // 5 elements to compute the valueHash
valueHash :=
    h{domain}(
        h{domain}(
            h{domain}(nonce||codesize||0, balance),
            h{domain}(
                storageRoot,
                compressedKeccakCodeHash,
            ),
        ),
        poseidonCodeHash,
    )
```

#### Storage Leaf Node

A Storage Leaf Node encodes a key-value pair, which both key and value are `u256` values. The secure key of this leaf node is derived from the storage key.

```go
var storageKey byte[32]  // 32 bytes in big-endian
valHi := storageKey[0:16]
valLo := storageKey[16:32]
nodeKey := h{256}(valHi, valLo)
```

The storage value is a `u256` value. The `flag` for the storage value is 1, showed below.

```
         +--------------+
  index  |      0       |
         +--------------+
  u256   | storageValue |
         +--------------+
flag bit |      1       |
         +--------------+
```

The value hash is computed as follows

```go
valueHash = h{512}(storageValue[0:16], storageValue[16:32])
```
